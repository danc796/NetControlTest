"""
Encryption utilities for the NC Client.
Implements AES encryption via the Fernet implementation for secure communication.
"""

"""
Encryption utilities for the NC Client.
Implements RSA + AES hybrid encryption for secure communication.
"""

import logging
import struct
from cryptography.fernet import Fernet
from cryptography.hazmat.primitives.asymmetric import padding
from cryptography.hazmat.primitives import serialization, hashes

class EncryptionManager:
    """Client-side encryption manager using AES via Fernet"""

    def __init__(self):
        """Initialize client encryption manager"""
        # RSA key for secure key exchange (will be received from server)
        self.server_rsa_public_key = None

        # AES encryption key (generated by client)
        self.encryption_key = None
        self.cipher_suite = None

    def perform_key_exchange(self, socket):
        """Perform RSA + AES key exchange with server"""
        try:
            # Step 1: Receive RSA public key from server
            public_key_size_bytes = socket.recv(4)
            if len(public_key_size_bytes) != 4:
                raise ConnectionError("Failed to receive public key size")

            public_key_size = struct.unpack('>I', public_key_size_bytes)[0]

            # Receive public key
            public_key_bytes = b''
            while len(public_key_bytes) < public_key_size:
                chunk = socket.recv(public_key_size - len(public_key_bytes))
                if not chunk:
                    raise ConnectionError("Connection closed while receiving public key")
                public_key_bytes += chunk

            logging.info(f"Received RSA public key ({public_key_size} bytes) from server")

            # Step 2: Deserialize server's RSA public key
            self.server_rsa_public_key = serialization.load_pem_public_key(public_key_bytes)

            # Step 3: Generate AES key
            self.encryption_key = Fernet.generate_key()

            # Step 4: Encrypt AES key with server's RSA public key
            encrypted_aes_key = self.server_rsa_public_key.encrypt(
                self.encryption_key,
                padding.OAEP(
                    mgf=padding.MGF1(algorithm=hashes.SHA256()),
                    algorithm=hashes.SHA256(),
                    label=None
                )
            )

            # Step 5: Send encrypted AES key to server
            encrypted_key_size = len(encrypted_aes_key)
            socket.send(struct.pack('>I', encrypted_key_size))
            socket.send(encrypted_aes_key)

            logging.info(f"Sent encrypted AES key ({encrypted_key_size} bytes) to server")

            # Step 6: Create Fernet cipher with our AES key
            self.cipher_suite = Fernet(self.encryption_key)
            logging.info("RSA + AES hybrid encryption successfully established")

            return True

        except Exception as e:
            logging.error(f"Error during key exchange: {e}")
            logging.warning("Falling back to unencrypted communication")
            # Create a dummy self-reference for compatibility
            self.cipher_suite = self
            return False

    def set_encryption_key(self, key):
        """Set encryption key from server and initialize cipher"""
        try:
            self.encryption_key = key

            # Create the Fernet cipher using the received key
            self.cipher_suite = Fernet(key)
            logging.info("AES encryption initialized successfully")
            return True
        except Exception as e:
            logging.error(f"Error initializing cipher with key: {e}")
            logging.warning("Falling back to unencrypted communication")
            # Create a dummy self-reference for compatibility
            self.cipher_suite = self
            return False

    def encrypt_data(self, data):
        """Encrypt data using Fernet (AES)"""
        if not self.cipher_suite or self.cipher_suite == self:
            logging.debug("Encryption not initialized, using unencrypted data")
            if isinstance(data, str):
                return data.encode()
            return data

        if isinstance(data, str):
            data = data.encode()
        try:
            return self.cipher_suite.encrypt(data)
        except Exception as e:
            logging.error(f"Encryption error: {e}")
            return data

    def decrypt_data(self, encrypted_data):
        """Decrypt data using Fernet (AES)"""
        if not self.cipher_suite or self.cipher_suite == self:
            logging.debug("Decryption not initialized, using raw data")
            if isinstance(encrypted_data, bytes):
                try:
                    return encrypted_data.decode()
                except UnicodeDecodeError:
                    return str(encrypted_data)
            return str(encrypted_data)

        if isinstance(encrypted_data, bytes):
            try:
                decrypted = self.cipher_suite.decrypt(encrypted_data)
                return decrypted.decode()
            except Exception as e:
                logging.error(f"Decryption error: {e}")
                # Try to return as string if decryption fails
                try:
                    return encrypted_data.decode()
                except UnicodeDecodeError:
                    return str(encrypted_data)
        return str(encrypted_data)

    def encrypt(self, data):
        """Alias for encrypt_data (for compatibility)"""
        return self.encrypt_data(data)

    def decrypt(self, data):
        """Alias for decrypt_data (for compatibility)"""
        return self.decrypt_data(data)

    def hash_data(self, data):
        """Create a secure hash of data"""
        if isinstance(data, str):
            data = data.encode()
        import hashlib
        return hashlib.sha256(data).hexdigest()

    def verify_hash(self, data, hash_value):
        """Verify hash value against data"""
        computed_hash = self.hash_data(data)
        return computed_hash == hash_value


# Standalone functions for backward compatibility
def hash_data(data):
    """Standalone hash function"""
    if isinstance(data, str):
        data = data.encode()
    import hashlib
    return hashlib.sha256(data).hexdigest()


def verify_hash(data, hash_value):
    """Verify hash against data"""
    computed_hash = hash_data(data)
    return computed_hash == hash_value